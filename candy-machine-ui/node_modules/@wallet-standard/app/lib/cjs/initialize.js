"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialize = void 0;
let initializedWallets = undefined;
/**
 * TODO: docs
 */
function initialize() {
    var _a;
    // If the API is already initialized by us, just return.
    if (initializedWallets)
        return initializedWallets;
    // If we're not in a window (e.g. server-side rendering), initialize and return.
    if (typeof window === 'undefined')
        return (initializedWallets = Object.freeze({ register, get, on }));
    // Since we didn't initialize the API, if it's not array, it was initialized externally, so throw an error.
    const wallets = ((_a = window.navigator).wallets || (_a.wallets = []));
    if (!Array.isArray(wallets))
        throw new Error('window.navigator.wallets was already initialized');
    // Initialize the API and overwrite window.navigator.wallets with a non-writable push API.
    initializedWallets = Object.freeze({ register, get, on });
    Object.defineProperty(window.navigator, 'wallets', { value: Object.freeze({ push }) });
    // Call all the wallet callbacks and return.
    push(...wallets);
    return initializedWallets;
}
exports.initialize = initialize;
const registered = new Set();
const listeners = {};
function push(...callbacks) {
    callbacks.forEach((callback) => guard(() => callback({ register })));
}
function register(...wallets) {
    var _a;
    // Filter out wallets that have already been registered.
    // This prevents the same wallet from being registered twice, but it also prevents wallets from being
    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.
    wallets = wallets.filter((wallet) => !registered.has(wallet));
    // If there are no new wallets to register, just return a no-op unregister function.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    if (!wallets.length)
        return () => { };
    wallets.forEach((wallet) => registered.add(wallet));
    (_a = listeners['register']) === null || _a === void 0 ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets)));
    // Return a function that unregisters the registered wallets.
    return function unregister() {
        var _a;
        wallets.forEach((wallet) => registered.delete(wallet));
        (_a = listeners['unregister']) === null || _a === void 0 ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets)));
    };
}
function get() {
    return [...registered];
}
function on(event, listener) {
    var _a;
    ((_a = listeners[event]) === null || _a === void 0 ? void 0 : _a.push(listener)) || (listeners[event] = [listener]);
    // Return a function that removes the event listener.
    return function off() {
        var _a;
        listeners[event] = (_a = listeners[event]) === null || _a === void 0 ? void 0 : _a.filter((existingListener) => listener !== existingListener);
    };
}
function guard(callback) {
    try {
        callback();
    }
    catch (error) {
        console.error(error);
    }
}
//# sourceMappingURL=initialize.js.map